---
title: "Assignment2_ClassificationModels"
author: "R.Riddell"
date: "05/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(caret)
library(rattle)
library(pROC)
library(naniar)
library(ggplot2)
library(stringr)
```

```{r Read in data, include=FALSE}
df <- read_csv('2014_NBA_shot-data.csv')
```

```{r View Data, include=FALSE}
glimpse(df)

# Add a variable to the whole data frame, as these variables are only ever calculated based off the individual obeservation they should not affect
## the out of sample data
df <- df %>% 
  mutate(last_5 = if_else(period == 4 & minutes_remaining < 5, 1,0)) 
df <- df %>% 
  mutate(Overtime = if_else(period == 5 | period == 6 | period == 7, 1, 0)) 
df$close_def_dist_simple <- cut_number(df$close_def_dist,n = 5)


# through some later exploration I found these observations that gave 4 or 6 points. I thought the 4 points could be getting fouled on a three point
## attempt but after checking box scores that did not seem to be the case. 
# I am not sure if these are errors in the dataset or there is some explanation I can't find. As they relate to only two players I am inclined to 
## think it is an error in the data
df %>% 
  select(pts,pts_type) %>% 
  mutate(diff = pts_type - pts) %>% 
  filter(diff < 0)
df %>% 
  filter(pts== 4 | pts ==6)

Matchup <- data.frame(str_split_fixed(df$matchup," ", n =7)) %>% 
  select(X1,X3,X7) %>% 
  rename('Month' = X1,
         'Year' = X3,
         'Opposition' = X7)
df <- cbind(df,Matchup)

df <- df %>% 
  select(-c(closest_defender,
         player_name,
         case_no,
         game_event_id,
         matchup,
         pts))

# scatterplot: game_id, 
# boxplot: team ID and prob
df <- df %>% 
  mutate_at(vars(location, shot_result,action_type,shot_type,
                 shot_zone_basic, shot_zone_area, shot_zone_range,
                 last_5, Overtime), as.factor)

```

```{r Na exploration, include=FALSE}
# this shows that all the missing values relate to the variable shot_clock
sum(is.na(df))
gg_miss_var(df)
vars_with_NA <- miss_var_which(df)

# the majority of these NA values seem to appear when theer is less than 24 seconds left in the period.
# due to think I belive they are due to the shot clock being "turned off" so have replaced the NA value with the seconds remaning value.
df %>% 
  select(c(vars_with_NA, seconds_remaining)) %>% 
  gg_miss_fct(fct = seconds_remaining) 
NA_obs <- df %>% 
  filter(is.na(shot_clock)) 
ggplot(NA_obs,aes(minutes_remaining)) + 
  geom_boxplot() 
ggplot(NA_obs,aes(seconds_remaining)) + 
  geom_boxplot()
df$shot_clock <- if_else(is.na(df$shot_clock) & df$seconds_remaining < 24 & df$minutes_remaining == 0, df$seconds_remaining, df$shot_clock)

# the other missing values don't seem to have a patten I can find other than most observations fall in the first three periods
NA_obs <- df %>% 
  filter(is.na(shot_clock)) 
ggplot(NA_obs,aes(period)) + 
  geom_boxplot() 
ggplot(NA_obs,aes(minutes_remaining)) + 
  geom_boxplot() 
ggplot(NA_obs,aes(seconds_remaining)) + 
  geom_boxplot()

# after looking at the relationship between mean shot clock and other variables I settled that period would be the best varible to base the 
## mean values off
df %>% 
  group_by(period) %>%
  summarise(clock = mean(shot_clock, na.rm= T)) %>% 
  ggplot(aes(period,clock)) + geom_point()
# as I am going to do the mean of other varaibles to deal with the remaining NA values I will do it after the data has been split to not affect the 
## out of sample performance



rm(vars_with_NA)
```

```{r split data}
set.seed(100)

inTrain <- createDataPartition(y = df$shot_result, p = 0.7, list = F)
training <-  df %>% 
  slice(inTrain)

testing <-  df %>% 
  slice(-inTrain)

dim(training)
dim(testing)

rm(inTrain)
```

```{r NA's, include=FALSE}
# imputing the mean of the period into the NA values and cloning the data frame
SC_mean_by_period <- training %>% 
  group_by(period) %>%
  mutate(clock = if_else(is.na(shot_clock), mean(shot_clock, na.rm = T), shot_clock)) 

SC_mean_by_period_values <- training %>% 
  group_by(period) %>%
  summarise(clock = mean(shot_clock, na.rm = T))

# calculing the total mean of shot clock and imputing into a cloned data frame for evalution
SC_mean <- if_else(is.na(training$shot_clock), mean(training$shot_clock, na.rm = T), training$shot_clock)

# binding the three columns together to compare the NA values have been filled and what the difference is between column mean and mean by period
NA_check <- cbind(training$shot_clock, SC_mean_by_period$clock, SC_mean)
na_mean_check <- which(is.na(training$shot_clock))
#NA_check[na_mean_check,]

# rounding the imputed values back to two digits
clock <- round(SC_mean_by_period$clock, digits = 2)

# saving over the intial dataframe with the new values
training$shot_clock <- clock

# checking that all the NA values are gone
sum(is.na(training))

# imputing the NA values based of the training set into the testing set
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 1)] <- SC_mean_by_period_values$clock[1]
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 2)] <- SC_mean_by_period_values$clock[2]
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 3)] <- SC_mean_by_period_values$clock[3]
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 4)] <- SC_mean_by_period_values$clock[4]
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 5)] <- SC_mean_by_period_values$clock[5]
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 6)] <- SC_mean_by_period_values$clock[6]
testing$shot_clock[which(is.na(testing$shot_clock) & testing$period == 7)] <- SC_mean_by_period_values$clock[7]

sum(is.na(testing))

rm(NA_check, SC_mean, SC_mean_by_period, clock, na_mean_check,SC_mean_by_period_values)

training$shot_clock_simple <- cut_interval(training$shot_clock,n = 6)
testing$shot_clock_simple <- cut_interval(testing$shot_clock,n = 6)

```


```{r create variables, include=FALSE}

# FG % based on action type, concern is low number of obsverations on some action types
training <- training %>% 
  group_by(action_type) %>% 
  mutate(action_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) %>% 
  ungroup()

training <- training %>% 
  group_by(shot_zone_basic) %>% 
  mutate(shot_zone_basic_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed")))%>% 
  ungroup()

training <- training %>% 
  group_by(shot_zone_range) %>% 
  mutate(shot_zone_range_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) %>% 
  ungroup()

training <- training %>% 
  group_by(pts_type) %>% 
  mutate(FG_2pt_3pt = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) %>% 
  ungroup()

training <- training %>% 
  group_by(period) %>% 
  mutate(period_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) %>% 
  ungroup()

action_FG <- training %>% 
  group_by(action_type) %>% 
  summarise(action_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) 
testing <- left_join(testing,action_FG, by = 'action_type')

shot_zone_basic_FG <- training %>% 
  group_by(shot_zone_basic) %>% 
  summarise(shot_zone_basic_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed")))
testing <- left_join(testing,shot_zone_basic_FG, by = 'shot_zone_basic')

shot_zone_range_FG <- training %>% 
  group_by(shot_zone_range) %>% 
  summarise(shot_zone_range_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) 
testing <- left_join(testing,shot_zone_range_FG, by = 'shot_zone_range')

FG_2pt_3pt <- training %>% 
  group_by(pts_type) %>% 
  summarise(FG_2pt_3pt = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) 
testing <- left_join(testing,FG_2pt_3pt, by = 'pts_type')

period_FG <- training %>% 
  group_by(period) %>% 
  summarise(period_FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed")))  
testing <- left_join(testing,period_FG, by = 'period')

rm(action_FG,FG_2pt_3pt,period_FG,shot_zone_basic_FG,shot_zone_range_FG)
```



```{r EDA of y, include=FALSE}
training %>%  
  count(shot_result) %>% 
  mutate(prop = prop.table(n)) %>% 
  ggplot(aes(shot_result, prop, fill = shot_result)) +
  geom_bar(stat  = 'identity', position = 'dodge') +
  theme(legend.position = "none") 

```

```{r Boxplot}
gg_boxplot <- function(feature){
  ggplot(training, aes(shot_result,.data[[feature]], fill = shot_result))+
    geom_boxplot()
}

numeric_vars <- training %>% 
select(where(is.numeric), -shot_result) %>% 
  names(.)

for (i in seq_along(numeric_vars)) {
  print(gg_boxplot(numeric_vars[i]))
}
```


```{r Boxplot, include=FALSE}
# no clear affect on make or miss
training <- training %>% 
  select(-c(game_id,
            shot_number,
            minutes_remaining,
            seconds_remaining))

```


```{r Boxplot}
gg_barplot <- function(feature){
  ggplot(training, aes(.data[[feature]], fill = shot_result))+
    geom_bar(position = 'dodge')+
    xlab(paste(feature))+
    theme(axis.text.x = element_text(angle = 45))
}

factor_vars <- training %>% 
select(where(is.factor), -shot_result) %>% 
  names(.)

for (i in factor_vars) {
  print(gg_barplot(i))
}
```

```{r}
training %>% 
  group_by(action_type) %>% 
  count() %>% 
  mutate(Percet_obs = n/ (length(training$action_type))) %>% 
  arrange(-n)

training <-  training %>% 
  select(-action_type)
```


```{r Boxplot, include=FALSE}
# no clear affect on make or miss
training <- training %>% 
  select(-Year,
         Overtime,
         action_FG)
```



```{r Scatterplot, eval=FALSE, include=FALSE}
gg_scatter <- function(feature){
  training %>% 
  group_by(.data[[feature]]) %>% 
  mutate(FG = (sum(shot_result == 'made')) / (sum(shot_result == 'made') + sum(shot_result == "missed"))) %>% 
  ggplot(aes(.data[[feature]], FG)) +
    geom_point() +
    xlab('shot result') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1))  
  }

gg_scatter('shot_zone_basic')

created_vars <- c('shot_zone_range', 'action_type', 'shot_zone_basic', 'pts_type', 'period')

for (i in seq_along(created_vars)) {
  print(gg_scatter(created_vars[i]))
}

```



```{r NZV}
nearZeroVar(training, names = T)
```

```{r multicolinearity}
## create a correlation matrix of all the numeric variables
cor_mat <- training %>% 
  select(where(is.numeric)) %>% 
  cor(., method = 'spearman')

## select the variables that display multicolinearty above 0.8
cor_features <- findCorrelation(cor_mat, cutoff = 0.8, names = T, exact = FALSE)

## remove the variables that display multicolinearty
## leaving the variables that best represent the correlation
training <- training %>% 
  select(-all_of(cor_features))
```


--------------------------------------------------------------------------------------------------------------------------------------

```{r}
training <- training %>% 
  select(c(action_FG, loc_y, shot_zone_basic, touch_time, close_def_dist, shot_clock, shot_result))
```
`


```{r Cross validation, include=FALSE}
control_obj <- trainControl(
  method = "cv",
  number = 5,
  savePredictions = "final",
  classProbs = T, 
  summaryFunction = twoClassSummary
)

```


```{r Logistic Regression}
set.seed(345)
mdl_logreg <- train(shot_result~.,
                    data = training,
                    method = "glm",
                    family = 'binomial',
                    trControl = control_obj)
summary(mdl_logreg)

```


```{r Decsion tree}

set.seed(345)

tree_mdl  <- train(shot_result ~. , data = training ,
                   method = 'rpart',
                   tuneGrid = expand.grid(cp = seq(0.01,0.1,0.01)),
                   trControl = control_obj,
                   metric = "ROC")

tree_mdl
plot(tree_mdl)
rattle::fancyRpartPlot(tree_mdl$finalModel, sub = "", palettes = 'RdBu')
plot(varImp(tree_mdl), top =20)
```


```{r random forest}
training <- training[1:2000,]

set.seed(345)

rf_mdl  <- train(shot_result ~. , data = training ,
                   method = 'ranger',
                   trControl = control_obj,
                   verbose = FALSE)
                   

rf_mdl
glimpse(training)
```


```{r in sample performance}
resamps <- resamples(list(tree = tree_mdl,
                          rf = rf_mdl,
                          logreg = mdl_logreg))

bwplot(resamps)
summary(resamps)

```

```{r Apply to test}
```


```{r Confusion Matrix}
```


```{r ROC Curve}
```

